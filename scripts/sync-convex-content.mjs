import path from 'node:path';
import fs from 'node:fs/promises';
import process from 'node:process';
import dotenv from 'dotenv';
import {ConvexHttpClient} from 'convex/browser';
import {anyApi} from 'convex/server';

const api = anyApi;

dotenv.config({path: '.env.local'});

const GENERATED_MARKER_FILENAME = '.convex-generated';

function yamlString(value) {
  return JSON.stringify(String(value));
}

function toYyyyMmDd(timestampMs) {
  return new Date(timestampMs).toISOString().slice(0, 10);
}

function sanitizePathSegment(input) {
  const s = String(input)
    .trim()
    .toLowerCase()
    .normalize('NFKD')
    .replace(/[^\w.-]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .slice(0, 80);
  return s || 'untitled';
}

function splitHierarchy(input) {
  return String(input)
    .split(/\/|>/g)
    .map((s) => s.trim())
    .filter(Boolean);
}

function sanitizePath(input) {
  const cleaned = splitHierarchy(input)
    .map((segment) => sanitizePathSegment(segment))
    .join('/');
  return cleaned || 'untitled';
}

async function ensureGeneratedDir(dir) {
  await fs.mkdir(dir, {recursive: true});
  const markerPath = path.join(dir, GENERATED_MARKER_FILENAME);
  try {
    await fs.access(markerPath);
    return;
  } catch {
    await fs.writeFile(
      markerPath,
      'This directory is generated by scripts/sync-convex-content.mjs.\n'
    );
  }
}

async function clearGeneratedDir(dir) {
  await ensureGeneratedDir(dir);

  const markerPath = path.join(dir, GENERATED_MARKER_FILENAME);
  const entries = await fs.readdir(dir, {withFileTypes: true});
  await Promise.all(
    entries
      .filter((e) => path.join(dir, e.name) !== markerPath)
      .map((e) => fs.rm(path.join(dir, e.name), {recursive: true, force: true}))
  );
}

function renderBlogPostMdx(post) {
  const date = toYyyyMmDd(post.publishedAt ?? post.createdAt);
  const postSlug = sanitizePath(post.slug);
  const lines = [
    '---',
    `title: ${yamlString(post.title)}`,
    `slug: ${yamlString(`/notes/${postSlug}`)}`,
    `date: ${yamlString(date)}`,
  ];

  if (post.description) {
    lines.push(`description: ${yamlString(post.description)}`);
  }
  if (Array.isArray(post.tags) && post.tags.length > 0) {
    lines.push('tags:');
    for (const tag of post.tags) {
      lines.push(`  - ${yamlString(tag)}`);
    }
  }

  lines.push('---', '');
  const body = String(post.content ?? '').trimEnd();
  return `${lines.join('\n')}\n${body}\n`;
}

function renderDocMdx(doc, slugPath) {
  const lines = [
    '---',
    `title: ${yamlString(doc.title)}`,
    `slug: ${yamlString(slugPath)}`,
  ];

  if (doc.description) {
    lines.push(`description: ${yamlString(doc.description)}`);
  }
  if (typeof doc.docOrder === 'number') {
    lines.push(`sidebar_position: ${doc.docOrder}`);
  }

  lines.push('---', '');
  const body = String(doc.content ?? '').trimEnd();
  return `${lines.join('\n')}\n${body}\n`;
}

async function writeCategoryMeta(categoryDir, categoryLabel) {
  const categoryMetaPath = path.join(categoryDir, '_category_.json');
  const payload = {
    label: categoryLabel,
    collapsible: true,
    collapsed: false,
    link: {type: 'generated-index', title: categoryLabel},
  };
  await fs.writeFile(categoryMetaPath, `${JSON.stringify(payload, null, 2)}\n`);
}

async function main() {
  const argv = new Set(process.argv.slice(2));
  const requireSync = argv.has('--require') || process.env.CONVEX_SYNC_REQUIRED === 'true';
  const optionalSync = !requireSync;
  const skipSync = process.env.CONVEX_SYNC_SKIP === 'true';

  if (skipSync) {
    console.warn('[convex-content] Skipping sync: CONVEX_SYNC_SKIP=true.');
    return;
  }

  const convexUrl = process.env.CONVEX_URL;

  if (!convexUrl) {
    if (requireSync) {
      throw new Error('CONVEX_URL is required to sync published content.');
    }
    console.warn('[convex-content] Skipping sync: CONVEX_URL is not set.');
    return;
  }

  const repoRoot = process.cwd();
  const docsOutDir = path.join(repoRoot, 'docs', 'convex');

  const client = new ConvexHttpClient(convexUrl);
  let blogPosts;
  let docs;
  try {
    [blogPosts, docs] = await Promise.all([
      client.query(api.content.listPublished, {contentType: 'blog'}),
      client.query(api.content.listPublished, {contentType: 'doc'}),
    ]);
  } catch (err) {
    if (optionalSync) {
      console.warn('[convex-content] Skipping sync: failed to fetch published content.');
      console.warn(err instanceof Error ? err.message : err);
      return;
    }
    throw err;
  }

  await clearGeneratedDir(docsOutDir);

  await writeCategoryMeta(docsOutDir, 'Content');

  let notesWritten = 0;
  const notesDir = path.join(docsOutDir, sanitizePathSegment('Notes'));
  await fs.mkdir(notesDir, {recursive: true});
  await writeCategoryMeta(notesDir, 'Notes');

  for (const post of blogPosts) {
    const postSlug = sanitizePath(post.slug);
    const filename = `${postSlug.replaceAll('/', '--')}.mdx`;
    const filePath = path.join(notesDir, filename);
    await fs.writeFile(filePath, renderBlogPostMdx(post));
    notesWritten += 1;
  }

  let docsWritten = 0;
  const seenCategories = new Map();
  for (const doc of docs) {
    const categorySegments = doc.docCategory ? splitHierarchy(doc.docCategory) : ['Misc'];

    let categoryDir = docsOutDir;
    const categorySlugPath = categorySegments.map((s) => sanitizePathSegment(s)).join('/');
    for (const segment of categorySegments) {
      const dirName = sanitizePathSegment(segment);
      categoryDir = path.join(categoryDir, dirName);
      await fs.mkdir(categoryDir, {recursive: true});
      if (!seenCategories.has(categoryDir)) {
        await writeCategoryMeta(categoryDir, segment);
        seenCategories.set(categoryDir, true);
      }
    }

    const docSlug = sanitizePath(doc.slug);
    const filename = `${docSlug.replaceAll('/', '--')}.mdx`;
    const filePath = path.join(categoryDir, filename);
    const slugPath = `/${categorySlugPath}/${docSlug}`;
    await fs.writeFile(filePath, renderDocMdx(doc, slugPath));
    docsWritten += 1;
  }

  console.log(
    `[convex-content] Wrote ${notesWritten} note(s) and ${docsWritten} doc(s) to ${path.relative(repoRoot, docsOutDir)}.`
  );
}

await main();
